#!/usr/bin/env python3
"""Generate a human-readable catalog and a machine-readable inventory.

Outputs:
- docs/CATALOG.md
- docs/inventory.json
"""
from __future__ import annotations

import json
import os
from collections import Counter, defaultdict
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]
DOCS = ROOT / "docs"


def is_git_repo(path: Path) -> bool:
    return (path / ".git").is_dir()


def rel(p: Path) -> str:
    try:
        return str(p.relative_to(ROOT))
    except Exception:
        return str(p)


def scan(root: Path) -> dict:
    inventory: dict[str, any] = {
        "root": rel(root),
        "top": [],
        "repos": [],
        "counts": {
            "files": 0,
            "by_ext": {},
        },
    }

    # Top-level directories/files
    for entry in sorted(root.iterdir(), key=lambda p: (not p.is_dir(), p.name.lower())):
        if entry.name.startswith("."):
            continue
        item = {
            "name": entry.name,
            "path": rel(entry),
            "type": "dir" if entry.is_dir() else "file",
        }
        inventory["top"].append(item)

    # Discover nested git repos up to a reasonable depth
    repos = []
    for base, dirs, files in os.walk(root):
        # Skip hidden dirs
        dirs[:] = [d for d in dirs if not d.startswith(".")]
        p = Path(base)
        if (p / ".git").is_dir():
            repos.append(p)
            # Do not descend further into repos
            dirs[:] = []

    # Summaries per repo
    for repo_path in sorted(repos, key=lambda p: rel(p)):
        file_count = 0
        ext_counter = Counter()
        readme = None
        license_file = None
        for b, dnames, fnames in os.walk(repo_path):
            # Avoid hidden dirs except .git at root which we skip anyway
            dnames[:] = [d for d in dnames if not d.startswith(".") and d != ".git"]
            for fn in fnames:
                if fn.startswith("."):
                    continue
                file_count += 1
                # extension
                if "." in fn and not fn.startswith("."):
                    ext = fn.rsplit(".", 1)[-1].lower()
                    ext_counter[ext] += 1
                # candidate docs
                low = fn.lower()
                if low == "readme.md":
                    readme = rel(Path(b) / fn) if readme is None else readme
                if low in {"license", "license.md", "license.txt"}:
                    license_file = rel(Path(b) / fn)

        inventory["repos"].append(
            {
                "path": rel(repo_path),
                "files": file_count,
                "top_ext": ext_counter.most_common(10),
                "readme": readme,
                "license": license_file,
            }
        )

    # Global counts by extension (limit to reasonable size)
    by_ext = Counter()
    total_files = 0
    for b, dnames, fnames in os.walk(root):
        dnames[:] = [d for d in dnames if not d.startswith(".")]
        for fn in fnames:
            if fn.startswith("."):
                continue
            total_files += 1
            if "." in fn and not fn.startswith("."):
                by_ext[fn.rsplit(".", 1)[-1].lower()] += 1
    inventory["counts"]["files"] = total_files
    inventory["counts"]["by_ext"] = dict(by_ext.most_common(50))

    return inventory


def write_catalog(inv: dict) -> None:
    md = []
    md.append("# Workspace Catalog\n")
    md.append("This file is generated by `scripts/gen_catalog.py`.\n")

    md.append("\n## Top-Level Items\n")
    for item in inv["top"]:
        icon = "ðŸ“" if item["type"] == "dir" else "ðŸ“„"
        md.append(f"- {icon} `{item['path']}`")

    md.append("\n## Nested Git Repositories\n")
    for repo in inv["repos"]:
        md.append(f"- `{repo['path']}` â€” files: {repo['files']}")
        if repo.get("readme"):
            md.append(f"  - README: `{repo['readme']}`")
        if repo.get("license"):
            md.append(f"  - License: `{repo['license']}`")
        if repo.get("top_ext"):
            exts = ", ".join(f"{e}Ã—{n}" for e, n in repo["top_ext"])
            md.append(f"  - Top extensions: {exts}")

    md.append("\n## Global File Counts\n")
    md.append(f"- Total files: {inv['counts']['files']}")
    top_ext = ", ".join(f"{e}Ã—{n}" for e, n in inv["counts"]["by_ext"].items())
    md.append(f"- By extension: {top_ext}")

    DOCS.mkdir(parents=True, exist_ok=True)
    (DOCS / "CATALOG.md").write_text("\n".join(md) + "\n", encoding="utf-8")
    (DOCS / "inventory.json").write_text(json.dumps(inv, indent=2), encoding="utf-8")


def main() -> None:
    inv = scan(ROOT)
    write_catalog(inv)
    print(f"Wrote {rel(DOCS / 'CATALOG.md')} and {rel(DOCS / 'inventory.json')}")


if __name__ == "__main__":
    main()

